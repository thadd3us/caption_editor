╔════════════════════════════════════════════════════════════════════════════╗
║                    IMMUTABILITY VISUAL GUIDE                              ║
║                    Understanding the Architecture                          ║
╚════════════════════════════════════════════════════════════════════════════╝

THREE LAYERS OF IMMUTABILITY
════════════════════════════════════════════════════════════════════════════

┌─ Layer 1: COMPILE-TIME (TypeScript readonly) ─────────────────────────────┐
│                                                                             │
│  interface VTTCue {                                                        │
│    readonly id: string              ← Can't change at compile time        │
│    readonly startTime: number        ← TypeScript prevents mutation       │
│    readonly cues: readonly VTTCue[]  ← Nested readonly array             │
│  }                                                                         │
│                                                                             │
│  Cost: ZERO (compile-time only)                                           │
│  Benefit: HIGH (catches bugs during development)                          │
│  Coverage: 22 fields across schema                                        │
│                                                                             │
└─────────────────────────────────────────────────────────────────────────────┘

┌─ Layer 2: RUNTIME (Object.freeze) ────────────────────────────────────────┐
│                                                                             │
│  const cues = parseVTTCues(content)                                       │
│  Object.freeze(cues)  ← Throws error if someone tries: cues[0] = newCue │
│                                                                             │
│  Cost: 5-10% overhead (negligible)                                        │
│  Benefit: MEDIUM (catches accidents in development)                       │
│  Coverage: 6 locations (parseVTT, createEmptyDocument, etc)              │
│                                                                             │
└─────────────────────────────────────────────────────────────────────────────┘

┌─ Layer 3: SIGNAL TO FRAMEWORK (Spread operators) ──────────────────────────┐
│                                                                             │
│  // Before: document = { metadata, cues, history }                        │
│  // User updates cue:                                                     │
│  store.updateCue(cueId, { text: 'new text' })                           │
│  // After: document = { ...document, cues: [...updated] }               │
│                                    ↑                                      │
│           New reference signals Vue to re-render                          │
│                                                                             │
│  Cost: Extra object allocations (negligible for caption editing)         │
│  Benefit: HIGH (Vue/AG Grid see changes, enable efficient updates)       │
│  Coverage: 14 instances across store and utilities                       │
│                                                                             │
└─────────────────────────────────────────────────────────────────────────────┘


THE FLOW: FROM MUTABLE USER INPUT TO IMMUTABLE STATE
════════════════════════════════════════════════════════════════════════════

User clicks "Edit Caption"
          ↓
┌─────────────────────────────────────────────────────────────────────────┐
│ AG GRID receives user input (mutable text in editor)                   │
│ Calls: store.updateCue(cueId, { text: newText })                      │
└─────────────────────────────────────────────────────────────────────────┘
          ↓
┌─────────────────────────────────────────────────────────────────────────┐
│ STORE ACTION (Pinia)                                                   │
│   const cue = document.value.cues.find(c => c.id === cueId)           │
│   const updatedCues = document.cues.map(c =>                          │
│     c.id === cueId ? { ...c, text: newText, timestamp } : c           │
│   )                                                                    │
│   document.value = {                                                  │
│     ...document.value,                                               │
│     cues: sortCues(updatedCues)  ← NEW REFERENCE!                   │
│   }                                                                    │
└─────────────────────────────────────────────────────────────────────────┘
          ↓
┌─────────────────────────────────────────────────────────────────────────┐
│ VUE REACTIVITY                                                         │
│   gridKey = computed(() =>                                           │
│     store.document.cues.map(c => c.id).join(',')                    │
│   )                                                                   │
│   gridKey changed! → Component re-renders                           │
└─────────────────────────────────────────────────────────────────────────┘
          ↓
┌─────────────────────────────────────────────────────────────────────────┐
│ AG GRID UPDATES                                                        │
│   :immutableData="true"  ← Tell grid: use ID-based comparison       │
│   :rowData="newRowData"  ← Passed down with new cues array         │
│   Grid compares by ID:                                             │
│     Old row ID 'cue-1': { text: 'old', startTime: 1 }             │
│     New row ID 'cue-1': { text: 'new', startTime: 1 }             │
│   Different! → Update DOM efficiently                             │
└─────────────────────────────────────────────────────────────────────────┘
          ↓
┌─────────────────────────────────────────────────────────────────────────┐
│ USER SEES: Caption updated in grid and synced with media playback    │
└─────────────────────────────────────────────────────────────────────────┘


THE PENDING PATTERN (VTT Parser Quirk)
════════════════════════════════════════════════════════════════════════════

VTT Format Structure:
┌────────────────────────────────┐
│ NOTE CAPTION_EDITOR:VTTCue {}  │  ← Metadata comes FIRST
│                                │     (id, rating, timestamp)
│ 00:00:01.000 --> 00:00:04.000 │  ← Timing line comes SECOND
│ Caption text                   │  ← Text comes THIRD
└────────────────────────────────┘

Parser Challenge:
┌─ Iteration 1: Read NOTE ─┐
│ pendingCue = { id, rating, timestamp }
│ Keep waiting for timing line...
└──────────────────────────┘
         ↓
┌─ Iteration 2: Read timing line ──────┐
│ Combine:                              │
│   - id, rating, timestamp from pending
│   - startTime, endTime from timing
│   - text from text line
│ Create complete VTTCue
└───────────────────────────────────────┘

Problem: Code duplication (happens in 2 parsing paths)

┌─ Path 1: No identifier (lines 183-199) ──┐
│ const id = pendingCue?.id || uuidv4()    │  ← Duplicate extraction
│ const rating = pendingCue?.rating        │     across both paths
│ const timestamp = pendingCue?.timestamp  │
│ const speakerName = pendingCue?.speaker  │
│ cues.push({ id, rating, ... })          │
│ pendingCue = null                        │
└──────────────────────────────────────────┘

┌─ Path 2: With identifier (lines 241-257) ──┐
│ const id = identifier || pendingCue?.id    │  ← SAME CODE AGAIN
│ const rating = pendingCue?.rating          │     (duplicated)
│ const timestamp = pendingCue?.timestamp    │
│ const speakerName = pendingCue?.speaker    │
│ cues.push({ id, rating, ... })            │
│ pendingCue = null                          │
└────────────────────────────────────────────┘

Solution: Extract to helper function

function createCueFromPending(
  pending: VTTCue | null,
  startTime: number,
  endTime: number,
  text: string,
  optionalId?: string
): VTTCue {
  return {
    id: optionalId || pending?.id || uuidv4(),
    startTime,
    endTime,
    text,
    speakerName: pending?.speakerName,
    rating: pending?.rating,
    timestamp: pending?.timestamp
  }
}

// Both paths now become:
cues.push(createCueFromPending(pendingCue, startTime, endTime, text, id))
pendingCue = null

Saves: ~15 lines of duplication while keeping immutability!


MUTABLE vs IMMUTABLE COMPARISON
════════════════════════════════════════════════════════════════════════════

IMMUTABLE (Current)                 MUTABLE (Alternative)
──────────────────────────────────  ──────────────────────────────────
store.updateCue(cueId, updates)    store.updateCue(cueId, updates)
    ↓ Returns new document             ↓ Mutates in place
document.value = newDoc            // document.value is SAME reference
    ↓ Reference changed             // Reference didn't change
Vue sees change                    Vue DOESN'T see change
    ↓                               // Need manual handling:
Auto re-render triggered           - Option A: gridApi.refreshCells()
    ↓                               - Option B: Vue.set(doc, ...)
Grid detects via gridKey           - Option C: document.value={...}
    ↓                               // Option C defeats the purpose!
Efficient update by ID
    ↓
Only changed rows updated


AG GRID WITHOUT IMMUTABLE DATA
════════════════════════════════════════════════════════════════════════════

Current Setup:
  :immutableData="true"    ← "Assume data is immutable"
  :key="gridKey"           ← "Re-render when gridKey changes"

If we go mutable:
  :immutableData="true"    ← Can't use! (data IS mutable)
  Need to switch to:
  :immutableData="false"   ← Less efficient
                            ← Grid watches all properties
                            ← More computation per update
                            ← Slower rendering

OR manual refresh everywhere:
  store.updateCue(cueId, updates)
  gridApi.value?.refreshCells()  ← Easy to forget!
                                  ← Error-prone
                                  ← Inconsistent behavior


DECISION TREE: SHOULD WE SWITCH TO MUTABLE?
════════════════════════════════════════════════════════════════════════════

Is performance a problem?           → NO
                                        ↓
Do we need undo/redo?              → MAYBE (nice to have)
                                        ↓ (if yes, keep immutable)
Is Vue reactivity working?         → YES (perfectly)
                                        ↓
Is the code too complex?           → NO (well-designed)
                                        ↓
Would we save significant lines?   → ONLY ~250 lines (31%)
                                        ↓
Is that worth losing all these?
  - Compile-time safety
  - Vue reactivity auto-detection
  - AG Grid efficiency
  - Easy undo/redo
  - Testing verification
                                    → NO! Keep immutable.


VERDICT
════════════════════════════════════════════════════════════════════════════

Current approach: EXCELLENT

The immutable-first architecture is well-designed for:
  ✓ Vue.js integration
  ✓ AG Grid efficiency
  ✓ Type safety
  ✓ Runtime safety
  ✓ Debugging clarity
  ✓ Future undo/redo

Saves: ~250 lines of code by going mutable
Costs: High-impact losses in safety, reactivity, grid efficiency

Trade-off verdict: NOT WORTH IT

Recommendation: KEEP IMMUTABLE

Optional: Extract pending pattern helper (~15 lines saved without losses)

